ArrayList: 인덱스가 부여됨. 공간 내 데이터들이 연속적으로 저장되어있음.
- 장점: 속도
- 단점: 추가삽입
 >> 데이터가 배열의 중간에 삽입되기 위해선 지정된 자리를 내어주고 그 자리에 있던 데이터와 그 뒤쪽에 있던 데이터들은 밀려난다.
 >> 데이터가 삭제될 경우 비워진 자리를 채우기 위해 그 뒤에 있던 데이터들이 빈 공간만큼 앞으로 이동된다.
( * 보통 데이터의 추가 및 삭제는 흔하게 발생하는 일이 아니라서 장점을 포기할 만큼의 단점은 아님)

LinkedList: 인덱스가 &1, &2, ... 인 형태임. ArrayList에 비해 느리지만 다른 형태의 컬렉션들보다는 빠름.
	: 지정되지 않은 공간에 저장된 데이터들에 대한 주소값(링크)만 저장된 배열.
 >> 데이터의 삭제 시 링크만 해제하고 그 다음 주소값인 링크와 연결함.
 >> 데이터의 추가 시 추가된 데이터에 대해 연결하고 기존의 링크(추가 데이터 기준 바로 양 옆) 해제.

vector: (**벡터의 3요소 속도 시간 방향) 배열과 유사하지만 데이터의 수정이 쉬운 동적 배열구조 클래스.
 >> 초기에 배열의 크기를 10으로 선언해줬다고 해도 배열의 마지막 데이터에 대한 추가와 삭제는 수월함(클래스로 선언되어있기 때문에 가능). sql의 varchar(예상 문자열 길이)와 같은 듯. 저장할 데이터들이 가변적인 경우에 사용하기 좋다.
 >> 구현이 쉽다. 랜덤하게 직접적인 접근이 가능하다.
 >> 그러나 중간의 데이터에 대한 추가 및 삭제는 배열의 단점과 매우 유사함: 배열의 중간에 위치한 데이터들의 추가 및 삭제에 대해 불리함.
 >> 다량의 데이터에 대한 검색이 느리다.

Hash: 값(원본 데이터) > hash함수 > 값(이 때 해당 해시값은 중복되지도 않고 순차적이지도 않다.)
HashSet: Hash값의 집합.
 >> 예시
 group 영화인: 회원 1, 회원 2, 회원 4, ...
 group 음악인: 회원 2, 회원 3, 회원 4, ...
 영화인과 음악인에 모두 해당되는 회원: 회원 2, 회원 4, ... >> 이 때 HashSet 사용
HashSet이 많이 사용되지 않는 이유
: db에서 빼내와서 직접  HashSet에 담는 건 아님
: 2개 이상의 데이터를 가져올 때, 이 데이터를 저장하는데 요구하는 공간(테이블)의 크기가 달라짐.
>> 메모리 문제로 컴퓨터의 성능을 저하시키는 문제 발생

이진트리: 노드 밑으로 두 개의 노드가 연결되는 자료구조. 최상위 노드를 root라고 부름. 특정 데이터를 빠르게 검색하기 위해 만들어진 자료구조.
전위탐색: 위(가운데) > 왼쪽 > 오른쪽
중위탐색: 왼쪽 > 위 > 오른쪽 (* 자바)
후위탐색: 왼쪽 > 오른쪽 > 위

HashMap: (* Java Spring)
Map.put("1", "김뫄뫄");
Map.put("3", "김솨솨");
get("1"); >> 출력결과: "김뫄뫄"
